Map - встроенная структура данных, которая связывает значения данных с ключами.
Ключ карды должен быть сопоставим(**comparable**). Срезы, карты и функции не могут являться ключами, т.к. их нельзя сравнивать.
Создается с помощью **make**. Можно создать сразу с значениями
```go
products := map[string]float64 {  
	"Kayak" : 279,  
	"Lifejacket": 48.95,  
}
```
При чтении отсутствующего ключа, возвращается нулевое значение для типа значения. Это может затруднить различение сохраненного нулевого значения и несуществующего ключа.
Для решения данной проблемы существует два значения при чтении значения:
```go
products := map[string]float64 {  
	"Kayak" : 279,  
	"Lifejacket": 48.95,  
	"Hat": 0,  
}  
// первый вариант
value, ok := products["Hat"]  
if (ok) {  
	fmt.Println("Stored value:", value)  
} else {  
	fmt.Println("No stored value")  
}
// второй вариант
if value, ok := products["Hat"]; ok {  
	fmt.Println("Stored value:", value)  
} else {  
	fmt.Println("No stored value")  
}
```

Элементы удаляются с карты с помощью  функции **delete**. Если указанный ключ не содержится в карте, то ничего не произойдет.
```go
delete(products, "Hat")
```
Перечислять содержимое карты можно с помощью **for** и **range**. Содержимое в цикле может перечисляться в случайном порядке.
```go
for key, value := range products {  
	fmt.Println("Key:", key, "Value:", value)  
}
```
Для того, чтобы получить значения в карте по порядкуЮ то лучший подход - перечислить карту и создать срез, содержащий ключи, отсортировать срез, а затем пронуменовать срез для чтения значений с карты.
```go
keys := make([]string, 0, len(products))  
	for key, _ := range products {  
	keys = append(keys, key)  
}  
sort.Strings(keys)  
	for _, key := range keys {  
	fmt.Println("Key:", key, "Value:", products[key])  
}
```

## Конкурентность
Карты не безопасны для конкурентного использования: не определено, что происходит, когда чтение и запись происходит одновременно. Если нужно читать и записывать на карту из разных горутин, то нужен механизм синхронизации. Чтение из map - безопасно.

Первый вариант - использовать **Mutex**: создать новую структуру данных и встроить в неё мьютекс.
```go
type Counters struct {
	sync.Mutex
	m map[string]int
}
```
Второй вариант - использовать **RWMutex**: аналогичен первому варианту, но помимо **Lock()/Unlock** есть аналогичные методы **RLock()/RUnlock()** для блокирования записи. Перед чтением делается *RLock()* и блокируются только вызовы *Lock()*, вызовы *RLock()* спокойно проходят. Таким образом обеспечивается параллельное чтение объекта несколькими горутинами, что улучшает производительность.

RWMutex может создать проблему конфликтов кеша: при блокировке на чтение, кождая горутина должна обновить поле ***readerCount***. Они дела это атомарно с помощью функции **sync/atomic atomic.AddInt32()**. Эти функции реализованы на ассемблере и оптимизированы под архитектуру конкретного  процессора. Когда каждое ядро процессора обновляет счётчик, оно собрасывает кеш для этого адреса в памяти для всех остальных ядер. Следующее ядро, прежде чем обновить счётчик, должно сначала вымитать это значение из кеша другого ядра. Передача между L2 кешем занимает около 40 наносекунд. А т.к. ядер много, то операция из константного времени превращается в O(N) по количеству ядер. Эта проблема называется cache contention.
### sync.Map

Решает проблему cache contention для случаев, когда в map происходит намного больше чтений, чем записей. Если совершенно чётко не обнаружена проблема узкого места из-за *map+RWMutex*, то выгоды скорее всего не будет, также возможно небольшая потеря в скорости. По производительности sync.Map гарантирует константное время доступа к map всне зависимости от количества одновременных чтений и количества ядер, но если ядер <4, то при большом количестве параллельных чтений, может быль существенно медленнее.

## Under the hood
 Мапа в Go - просто указатель на структура hmap. Поэтому мапа передается в функцию по значению. Данные расположены в массивах по 8 пар ключ/элемент (**buckets**). Младшие биты хеша используются для выбора ведра. Каждое ведро содержит старшие биты каждого хэша для различения записей внутри одного ведра. Если в одном ведре больше 8 ключей, то мы цепляем дополнительные ведра.
 Когда хеш-таблица растет, мы  ведыляем новый массив ведер в два раза больше. Некоторое время Go хранит старые бакеты вместе с новыми, чтобы избежать пиковых нагрузок и гарантировать безопасное завершение уже запущенных итераторов.
 ![[Pasted image 20230216104345.png]]

Если мы знаем, сколько предметов нужно поместить в мапу, то лучше указывать размер при создании, таким образом можно избежать затрат на процесс роста.

Мапа может только расти. Даже при удалении всех значений, количество ведер останется прежним, как и потребление памяти.

Итераторы мапы проходят через массив ведер и возвращают ключи по порядку обхода.

```go
type hmap struct {  
   flags     uint8  
   B         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)  
   noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details   hash0     uint32 // hash seed  
  
   buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.  
   oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing  
   nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)  
   extra *mapextra // optional fields  
}
```

### Как происходит поиск? (простыми словами)
![[141136940c244e6c0d5c820a2c44cabf.jpg]]
- Передаем ключ "The Matrix" в хэш-функцию. Получаем uint64 - 18002143618149980261
- Вычисляем маску для наших бакетов. Она равна **n-1**, где n - количество бакетов.
- Вычисляем номер бакета, в котором сохраним наше значение. Для этого используем битовое **И**. **hash & mask == 18002143618149980261 & 3 == 01 & 11 == 01**, что равно 1 в десятичной системе счисления
- Идем в бакет по индексу 1 и перебором проверяем масисв на наличие нашего ключа. Если находим вопадение по ключу, то перезаписываем занчение, иначе добавлячем в первое свободное место.

## Хеш
При каждом создании магы генерируется seed для рандомизации хеш-функций, это сделано для безопасности, так так зная хеш-функцию можно подобрать такие ключи, что все значения попадут в один бакет и мы получим линейную скорость поиска.
При коллизиях используется стратегия closed addressing. Мы перебираем все ячейки бакета и ищем первое свободное место
### Источники

1. https://habr.com/ru/post/457728/
2. https://habr.com/ru/post/338718/
3. https://go.dev/src/runtime/map.go
4. https://go.dev/src/sync/map.go
5. https://hackernoon.com/some-insights-on-maps-in-golang-rm5v3ywh
6. https://medium.com/kalamsilicon/hash-tables-implementation-in-go-48c165c54553