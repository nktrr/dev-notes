TODO: Написать про потоки и прочее из таненбаума (хуйня, норм книжка лежит на диске)
Процесс - экземпляр программы, выполняемой операционной системой.
Поток - это единица выполнения, на работу которой операционная система дает некоторое врямя.
Параллелизм - это одновременное выполнение нескольких сущностей определенного вида
Конкурентность - способ структурирования компонентов, позволяющий им выполняться независимо, когда это возможно

Горутина - это минимальная сущность GO, которая может быть выполнена конкурентно .


Планировщик GO
Планировщик GO отвечает за выполнение горутин, используя технологию, называемую планированием m:n (m горутин выполняется в n потоках операционной системы посредством мультиплексирования.)

Плюсы горутин
1. Создание горутины занимает меньше времени, чем создание потока
2. Исходный размер стека горутин меньше размера стека потоков и может быть увеличен по мере необходимости
3. Преключение между горутинами занимает меньше времени, чем переключение между потоками, поскольку осуществляется полностью внутри процесса, что исключает необходимость выполнения сравнительно медленных системных вызовов.
4. Планировщик может оптимизировать свои решения. Взаимодействуя с сетевым опрашивателем, планировщик выявляет те случаи, при которых следует отменить выполнение горутины, чтобы она не блокировала ввод-вывод. Также он взаимодействует со сборщиком мусора и следит за тем, чтобы работа была равномерно распределена, между потоками операционной системы, выделенными для GO-процесса

Горутины общаются друг с другом посредством каналов. Представляют собой ссылочный тип. По умолчанию нулевым значением для каналов является nil

Чтение, запись и буферизация

```go
a := <- ch // считывает значение из канала ch и приваивает его переменной a
ch <- b // записывает значение переменной b в канал ch
```
Каждое записанное в канал значение может быть считано только один раз
Как указать направление канала:
```go
chan(ch <- chan int) // только чтение из канала
chan(ch chan <- int) // только запись в канал
```
При таком указании компилятор языка сможет гарантировать, что функция будет производить только чтение или только запись в канал.

По умолчанию канал является небуферизованным. После каждой операции записи в открытый небуферизованный канал прозводящая запись горутина делает паузу до тех пор, пока другая горутина не прочитает из этого канала и наоборот.

Буферизованные каналы буферизуют без блокировки некоторое ограниченное количество операций записи. Если же буфер заполнен и в него производят запись, то записывающая горутина остановится до чтения из канала. Аналогично при пустом буфере блокируется читающая горутина.

```go
ch := make(chan int, 10) // буферизованный канал
```
Емкость буфера нельзя изменить
len - получить текущее количество значений в буфере
cap - максимальный размер буфера
len =0  & cap = 0   если канал небуферизированый

Запись в закрытый канал - паника
Закрытие закрытого канала - паника
Чтение из закрытого буферизованного канала с оставшимися данными - вернутся данные в последовательном порядке
Чтение из небуф или буф без значений - возврат нулевых значений


|  | Небуферизо ванный окрытый | Небуферизо ванный закрытый | Буферизо ванный открытый | Буферизо ванный закрытый | NIL |
| ---- | ---- | ---- | ---- | ---- | ---- |
| Чтение | Stop until write | return empty-value | stop while buffer is empty | return values or empty-values | infinity stuck |
| Запись | Stop until read | panic | stop while buffer is full | panic | infinity stuck |
| Закрытие | work | panic | work, may return values if exists | panic | panic |

Закрытие горутин
Среда выполнения GO не может проверять, будет ли еще использоваться горутина или нет. Если горутина не закрыта, то планировщик продолжит периодически предоставлять ей время, которое она не будет использовать, что влияет на производительность. Эта проблема называется утечкой горутин. Это происходит если горутина остановилась на канале.

Пример блокировки

```go
func countTo(max int) <-chan int {
	ch := make(chan int)
	go func() {
		for i := 0; i < max; i++ {
			ch <- i
		}
		close(ch)
	}()
	return ch
}

func main() {
	for i := range countTo(10) {
		if i > 5 {
			break  // проебали
		}
		fmt.Println(i)
	}
}
```

Оператор select случайным обрразом выбирает один из тех кейсов, который может быть выполнен. Это полностью исключает вероятность зависания процессов из-за недостатка ресурсов, поскольку все ветви обладают одинаковым приоритетом и проверяются в одно и то же время.

Паттерн на основе канала done
Для уведомления горутин и том, что пора прекратить обработку, можно использовать отдельный канал (допустим с названием done). Так как при чтении из закрытого всегда возвращает нулевое значение, то в примере выполнится case и там уже можно выйти

```go
done := make(chan struct{})

go func(){
	select{
		case result <- searcher(s):
		case <- done:
	}
}
close(done)
```

Когда юзать буферизованные и небуферизованные каналы
// хуй знает
Буферизованные каналы следует использовать в том случае, когда известно количество запущенных горутин и нужно ограничить количество горутин, которые еще будут запущены, или если нужно ограничить объем работы, стоящей в очереди на выполнение.
Также заебись когда нужно собрать данные из некоторого набора запущенных горутин. 

Паттерн противодавление

```go
type PressureGauge struct {  
    ch chan struct{}  
}  
func New(limit int) *PressureGauge {  
    ch := make(chan struct{}, limit)  
    for i := 0; i < limit; i++ {  
       ch <- struct{}{}  
    }  
    return &PressureGauge{  
       ch: ch,  
    }  
}  
func (pg *PressureGauge) Process(f func()) error {  
    select {  
    case <-pg.ch:  
       f()  
       pg.ch <- struct{}{}  
       return nil  
    default:  
       return errors.New("no more capacity")  
    }  
}
```

Отключение ветвей оператора select
Чтобы каждый раз долго не долбиться в закрытый канал и не делать проверку, можно  присвоить переменной канала значение nil, после этого кейс уже не будет выполняться

Тайм-аут
Можно сделать прикол с time.After, но при этом горутина продолжит свою работу. Чтобы ее стопнуть нужно юзать контекстную отмену
```go
func timeLimit() (int, error) {  
    var result int  
    var err error  
    done := make(chan struct{})  
    go func() {  
       result, err = doSomeWork()  
       close(done)  
    }()  
    select {  
    case <-done:  
       return result, err  
    case <-time.After(2 * time.Second):  
       return 0, errors.New("work timed out")  
    }  
}
```

sync.WaitGroup
В целом понятно че делает. Приколы:
```go
go func(){
	defer wg.Done()  // выполнится даже в случае panic в горутине
	doSomeWork() 
}
```
Есть еще ErrGroup из пакета golang.org/x, созданный на основе WaitGroup, для получения группы горутин, прекращающих обработку в том случае, когда одна из них возвращает ошибку.

sync.Once можно юзать вместо init 